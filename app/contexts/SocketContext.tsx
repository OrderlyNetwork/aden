import React, { createContext, useContext, useEffect, useRef, useState } from 'react';
import { useUserStore } from '~/store/userStore';

interface ChatMessage {
  id: number;
  message: string;
  sender: {
    user_id: number;
    username: string;
    email: string;
    level: number;
    profile_image_url: string;
    direction?: string;
    liquidation_amount?: number;
    acquire_bugs?: number;
  };
  created_at: string;
}

// ÏÉàÎ°úÏö¥ Liquidation Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ (ÏÇ¨Ïö©Ïûê Ï†úÍ≥µ ÌòïÏãùÏóê ÎßûÏ∂§)
interface LiquidationExchangeData {
  exchange: string;
  liquidation_usd: number;
  longLiquidation_usd: number;
  shortLiquidation_usd: number;
}

interface LiquidationResponse {
  code: string;
  data: LiquidationExchangeData[];
}

interface LiquidationData {
  time_range: string;
  data: LiquidationResponse;
}

interface SocketContextType {
  chatConnected: boolean;
  liquidationSocketConnected: boolean;
  connectedUserCount: number;
  chatItems: ChatMessage[];
  sendMessage: (message: string) => void;
  messageIdCounter: React.MutableRefObject<number>;
  liquidationData: LiquidationData[]; // ÏÉàÎ°úÏö¥ ÌÉÄÏûÖÏúºÎ°ú Î≥ÄÍ≤Ω
  cleanup: () => void; // ÌÅ¥Î¶∞ÏóÖ Ìï®Ïàò Ï∂îÍ∞Ä
}

const SocketContext = createContext<SocketContextType | null>(null);

export const useSocket = () => {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
};

export const AppSocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user } = useUserStore();
  const [chatConnected, setChatConnected] = useState(false);
  const [liquidationSocketConnected, setLiquidationSocketConnected] = useState(false);
  const [connectedUserCount, setConnectedUserCount] = useState(0);
  const [chatItems, setChatItems] = useState<ChatMessage[]>([]);
  const chatSocketRef = useRef<WebSocket | null>(null);
  const liquidationSocketRef = useRef<WebSocket | null>(null);
  const messageIdCounter = useRef(1);
  const [liquidationData, setLiquidationData] = useState<LiquidationData[]>([]);
  // ÏµúÎåÄ Î©îÏãúÏßÄ Í∞úÏàò ÏÉÅÏàò Ï†ïÏùò
  const MAX_MESSAGES = 300;

  // WebSocket ÌÅ¥Î¶∞ÏóÖ Ìï®Ïàò
  const cleanupChatSocket = () => {
    if (chatSocketRef.current) {
      // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
      chatSocketRef.current.removeEventListener('open', () => { });
      chatSocketRef.current.removeEventListener('message', () => { });
      chatSocketRef.current.removeEventListener('error', () => { });
      chatSocketRef.current.removeEventListener('close', () => { });

      // WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å
      if (chatSocketRef.current.readyState === WebSocket.OPEN ||
        chatSocketRef.current.readyState === WebSocket.CONNECTING) {
        chatSocketRef.current.close(1000, 'Component unmounting');
      }
      chatSocketRef.current = null;
    }
    setChatConnected(false);
  };

  const cleanupLiquidationSocket = () => {
    if (liquidationSocketRef.current) {
      // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
      liquidationSocketRef.current.removeEventListener('open', () => { });
      liquidationSocketRef.current.removeEventListener('message', () => { });
      liquidationSocketRef.current.removeEventListener('error', () => { });
      liquidationSocketRef.current.removeEventListener('close', () => { });

      // WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å
      if (liquidationSocketRef.current.readyState === WebSocket.OPEN ||
        liquidationSocketRef.current.readyState === WebSocket.CONNECTING) {
        liquidationSocketRef.current.close(1000, 'Component unmounting');
      }
      liquidationSocketRef.current = null;
    }
    setLiquidationSocketConnected(false);
  };

  // Ï†ÑÏ≤¥ ÌÅ¥Î¶∞ÏóÖ Ìï®Ïàò
  const cleanup = () => {
    cleanupChatSocket();
    cleanupLiquidationSocket();

    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    setChatItems([]);
    setLiquidationData([]);
    setConnectedUserCount(0);
    messageIdCounter.current = 1;

    console.log('Socket context cleanup completed');
  };

  const identifyUser = () => {
    if (chatSocketRef.current?.readyState === WebSocket.OPEN && user.user_id !== -1 && String(user.user_id) !== "") {
      chatSocketRef.current.send(JSON.stringify({
        action: 'identify',
        data: {
          user_id: user.user_id,
          username: user.username,
          email: user.email,
          level: user.level,
          profile_image_url: !user.profile_image_url ? '/v2/images/blank_profile.webp' : user.profile_image_url
        }
      }));
    }
  };

  const processIncomingChatMessage = (data: any) => {
    if (!data || !data.data) {
      console.warn('Invalid message data received:', data);
      return;
    }

    if (data.action === 'recent_messages') {
      setConnectedUserCount(data.data.connected_user_count || 0);

      // messages Î∞∞Ïó¥Ïù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
      if (data.data.messages && Array.isArray(data.data.messages)) {
        // Î©îÏãúÏßÄ IDÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Ìï†Îãπ
        const messagesWithId = data.data.messages.map((message: any) => {
          if (!message) return null; // null Î©îÏãúÏßÄ Í±¥ÎÑàÎõ∞Í∏∞
          return {
            ...message,
            id: message.id || messageIdCounter.current++,
            sender: {
              user_id: message.sender?.user_id || -1,
              username: message.sender?.username || 'Unknown',
              email: message.sender?.email || '',
              level: message.sender?.level || 1,
              profile_image_url: message.sender?.profile_image_url || '/v2/images/blank_profile.webp',
              direction: message.sender?.direction,
              liquidation_amount: message.sender?.liquidation_amount,
              acquire_bugs: message.sender?.acquire_bugs,
            },
            message: message.message || '',
            created_at: message.created_at || new Date().toISOString(),
          };
        }).filter(Boolean); // null Í∞í Ï†úÍ±∞

        // ÏµúÎåÄ Î©îÏãúÏßÄ Í∞úÏàòÎ•º Ïú†ÏßÄÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïò§ÎûòÎêú Î©îÏãúÏßÄ Ï†úÍ±∞
        setChatItems(prev => {
          const combinedMessages = [...prev, ...messagesWithId];
          // Î©îÏãúÏßÄÍ∞Ä ÏµúÎåÄ Í∞úÏàòÎ•º Ï¥àÍ≥ºÌïòÎ©¥ Ïò§ÎûòÎêú Î©îÏãúÏßÄÎ•º Ï†úÍ±∞
          return combinedMessages.length > MAX_MESSAGES
            ? combinedMessages.slice(combinedMessages.length - MAX_MESSAGES)
            : combinedMessages;
        });
      }
    } else if (data.action === 'new_message') {
      setConnectedUserCount(data.data.connected_user_count || 0);

      // message ÎòêÎäî messages Í∞ùÏ≤¥ ÌôïÏù∏ (ÏÑúÎ≤ÑÏóêÏÑú messagesÎ°ú Î≥¥ÎÇº ÏàòÎèÑ ÏûàÏùå)
      const messageData = data.data.message || data.data.messages;
      if (messageData) {
        const newMessage = {
          ...messageData,
          id: messageData.id || messageIdCounter.current++,
          sender: {
            user_id: messageData.sender?.user_id || -1,
            username: messageData.sender?.username || 'Unknown',
            email: messageData.sender?.email || '',
            level: messageData.sender?.level || 1,
            profile_image_url: messageData.sender?.profile_image_url || '/v2/images/blank_profile.webp',
            direction: messageData.sender?.direction,
            liquidation_amount: messageData.sender?.liquidation_amount,
            acquire_bugs: messageData.sender?.acquire_bugs,
          },
          message: messageData.message || '',
          created_at: messageData.created_at || new Date().toISOString(),
        };

        // ÏÉà Î©îÏãúÏßÄÎ•º Ï∂îÍ∞ÄÌïòÍ≥† Î©îÏãúÏßÄÍ∞Ä ÏµúÎåÄ Í∞úÏàòÎ•º Ï¥àÍ≥ºÌïòÎ©¥ Í∞ÄÏû• Ïò§ÎûòÎêú Î©îÏãúÏßÄÎ•º Ï†úÍ±∞
        setChatItems(prev => {
          const newMessages = [...prev, newMessage];
          const result = newMessages.length > MAX_MESSAGES ? newMessages.slice(1) : newMessages;
          return result;
        });
      } else {
        console.log('üî¥ No message data found in new_message action. Available keys:', Object.keys(data.data));
      }
    }
  };

  const sendMessage = (message: string) => {
    if (chatSocketRef.current?.readyState === WebSocket.OPEN && message.trim()) {
      chatSocketRef.current.send(JSON.stringify({
        action: 'message',
        data: {
          text: message,
        }
      }));
      // Optimistic update
      const newMessage = {
        id: messageIdCounter.current++,
        message: message,
        sender: {
          user_id: user.user_id,
          username: user.username,
          email: user.email,
          level: user.level,
          profile_image_url: !user.profile_image_url ? '/v2/images/blank_profile.webp' : user.profile_image_url,
        },
        created_at: new Date().toISOString(),
      };

      // ÏÉà Î©îÏãúÏßÄÎ•º Ï∂îÍ∞ÄÌïòÍ≥† Î©îÏãúÏßÄÍ∞Ä ÏµúÎåÄ Í∞úÏàòÎ•º Ï¥àÍ≥ºÌïòÎ©¥ Í∞ÄÏû• Ïò§ÎûòÎêú Î©îÏãúÏßÄÎ•º Ï†úÍ±∞
      setChatItems(prev => {
        const newMessages = [...prev, newMessage];
        return newMessages.length > MAX_MESSAGES ? newMessages.slice(1) : newMessages;
      });
    }
  };

  // Chat WebSocket connection
  useEffect(() => {
    const socket = new WebSocket('ws://121.142.204.10:8080/ws/chat');
    chatSocketRef.current = socket;

    const handleOpen = () => {
      console.log('Connected to Chat WebSocket server');
      setChatConnected(true);
      identifyUser();
    };

    const handleMessage = (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data as string);
        if (data.action === "data_updated") {
          const customEvent = new CustomEvent('socket_data_updated', { detail: data });
          window.dispatchEvent(customEvent);
          return;
        }
        processIncomingChatMessage(data);
      } catch (error) {
        console.error('üî¥ Error parsing Chat WebSocket message:', error);
      }
    };

    const handleError = (event: Event) => {
      console.error('Chat WebSocket error:', event);
    };

    const handleClose = () => {
      setChatConnected(false);
    };

    socket.addEventListener('open', handleOpen);
    socket.addEventListener('message', handleMessage);
    socket.addEventListener('error', handleError);
    socket.addEventListener('close', handleClose);

    return () => {
      socket.removeEventListener('open', handleOpen);
      socket.removeEventListener('message', handleMessage);
      socket.removeEventListener('error', handleError);
      socket.removeEventListener('close', handleClose);

      if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
        socket.close(1000, 'Component unmounting');
      }
    };
  }, []);

  // Liquidation WebSocket connection
  useEffect(() => {
    const socket = new WebSocket('ws://121.142.204.10:8080/ws/liquidation');
    liquidationSocketRef.current = socket;

    const handleOpen = () => {
      console.log('Connected to Liquidation WebSocket server');
      setLiquidationSocketConnected(true);
      socket.send("get_data");
    };

    const handleMessage = (event: MessageEvent) => {
      try {
        const newLiquidationEntry = JSON.parse(event.data as string) as LiquidationData;

        setLiquidationData(prevData => {
          // time_rangeÏóê Îî∞Îùº Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ±∞ÎÇò ÏÉàÎ°ú Ï∂îÍ∞Ä
          const existingIndex = prevData.findIndex(item => item.time_range === newLiquidationEntry.time_range);

          if (existingIndex !== -1) {
            // Í∏∞Ï°¥ time_range Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            const updatedData = [...prevData];
            updatedData[existingIndex] = newLiquidationEntry;
            return updatedData;
          } else {
            // ÏÉàÎ°úÏö¥ time_range Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            return [...prevData, newLiquidationEntry];
          }
        });

      } catch (error) {
        console.error('Error parsing Liquidation WebSocket message:', error);
      }
    };

    const handleError = (event: Event) => {
      console.error('Liquidation WebSocket error:', event);
      setLiquidationSocketConnected(false);
    };

    const handleClose = () => {
      setLiquidationSocketConnected(false);
    };

    socket.addEventListener('open', handleOpen);
    socket.addEventListener('message', handleMessage);
    socket.addEventListener('error', handleError);
    socket.addEventListener('close', handleClose);

    return () => {
      socket.removeEventListener('open', handleOpen);
      socket.removeEventListener('message', handleMessage);
      socket.removeEventListener('error', handleError);
      socket.removeEventListener('close', handleClose);

      if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
        socket.close(1000, 'Component unmounting');
      }
    };
  }, []);

  // Re-identify when user changes for chat socket
  useEffect(() => {
    identifyUser();
  }, [user, chatConnected]); // chatConnected ÏÉÅÌÉúÎèÑ ÏùòÏ°¥ÏÑ±Ïóê Ï∂îÍ∞Ä

  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ï†ÑÏ≤¥ ÌÅ¥Î¶∞ÏóÖ
  useEffect(() => {
    return cleanup;
  }, []);

  const value = {
    chatConnected,
    liquidationSocketConnected,
    connectedUserCount,
    chatItems,
    sendMessage,
    messageIdCounter,
    liquidationData,
    cleanup, // ÌÅ¥Î¶∞ÏóÖ Ìï®ÏàòÎ•º Ïª®ÌÖçÏä§Ìä∏Ïóê ÎÖ∏Ï∂ú
  };

  return <SocketContext.Provider value={value}>{children}</SocketContext.Provider>;
}; 